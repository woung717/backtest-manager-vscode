// src/services/projectService.ts
import { ProjectInfo, BacktestResult, Config, Engine, Backtest } from '../types';
import * as path from 'path';
import { templateCodeFactory } from '../userCodeTemplates';
import { Database } from '../database'; // Import Database
import { promises as fsPromises } from 'fs'; // Import fs.promises

export interface IProjectService {
  getProjects(): Promise<ProjectInfo[]>;
  getProject(projectId: string): Promise<ProjectInfo | null>;
  getProjectByName(projectName: string): Promise<ProjectInfo | null>;
  createProject(projectName: string, engine: Engine, workspaceRootPath: string): Promise<ProjectInfo>;
  updateProject(projectId: string, projectData: Partial<ProjectInfo>): Promise<ProjectInfo | null>;
  deleteProject(projectId: string): Promise<boolean>;
  addBacktestResult(projectId: string, backtestResult: BacktestResult): Promise<ProjectInfo | null>;
  deleteBacktestResult(projectId: string, backtestResultId: string): Promise<ProjectInfo | null>; 
  updateLastConfig(projectId: string, config: Config): Promise<ProjectInfo | null>;
  getProjectStrategyClass(project: ProjectInfo): Promise<string | undefined>;
}


export class ProjectService implements IProjectService {
  private readonly entryFileName: string = 'main.py'; 

  constructor(private database: Database, private workspaceRootPath: string) {} // Updated constructor

  async getProjects(): Promise<ProjectInfo[]> {
    return await this.database.getProjects();
  }

  async getProject(projectId: string): Promise<ProjectInfo | null> {
    const project = await this.database.getProject(projectId);
    return project || null; // NeDB findOne can return undefined, ensure null if not found
  }

  async getProjectByName(projectName: string): Promise<ProjectInfo | null> {
    const project = await this.database.getProjectByName(projectName);
    return project || null; // Ensure null if not found
  }

  async createProject(projectName: string, engine: Engine, workspaceRootPath: string): Promise<ProjectInfo> {
    const projectPath = path.join(workspaceRootPath, projectName); // workspaceRootPath is the project's direct parent from input
    const entryFilePath = path.join(projectPath, this.entryFileName);
    
    await fsPromises.mkdir(projectPath, { recursive: true });
    const templateCode = templateCodeFactory(engine);
    await fsPromises.writeFile(entryFilePath, templateCode);

    // Prepare the full ProjectInfo object for database insertion
    const newProjectForDb: ProjectInfo = {
      // _id will be generated by NeDB
      name: projectName,
      path: projectPath,
      entryFile: this.entryFileName,
      engine: engine,
      strategy: undefined, // Explicitly undefined or determined later
      description: undefined,
      created: new Date(),
      updated: new Date(),
      results: [], // Initialize as empty array
      lastConfig: {} // Initialize as empty object or specific default config structure
    };
    
    // The database.addProject method (as refined in the previous step)
    // will ensure these fields are present if somehow missed, but it's good practice
    // for the service to define the initial complete structure.
    return await this.database.addProject(newProjectForDb);
  }

  async updateProject(projectId: string, projectData: Partial<ProjectInfo>): Promise<ProjectInfo | null> {
    await this.database.updateProject(projectId, projectData);
    return await this.getProject(projectId); // Fetch and return updated project
  }

  async deleteProject(projectId: string): Promise<boolean> {
    try {
      await this.database.deleteProject(projectId); // This throws if not found
      // Optionally, could add fs logic here to delete the project's directory from the filesystem
      // For now, as per original command, it only removes from manager.
      // const project = await this.getProject(projectId); // This would now be null or throw
      // if (project && project.path) {
      //   await fsPromises.rm(project.path, { recursive: true, force: true });
      // }
      return true;
    } catch (error) {
      console.error(`Error deleting project ${projectId}:`, error);
      return false; // Or rethrow if the caller should handle it
    }
  }

  async addBacktestResult(projectId: string, backtestResult: BacktestResult): Promise<ProjectInfo | null> {
    await this.database.addBacktestResult(projectId, backtestResult);
    return await this.getProject(projectId);
  }

  async deleteBacktestResult(projectId: string, backtestResultId: string): Promise<ProjectInfo | null> {
    await this.database.deleteBacktestResult(projectId, backtestResultId);
    return await this.getProject(projectId);
  }

  async updateLastConfig(projectId: string, config: Config): Promise<ProjectInfo | null> {
    await this.database.updateLastConfig(projectId, config);
    return await this.getProject(projectId);
  }

  public async getProjectStrategyClass(project: ProjectInfo): Promise<string | undefined> {
    const entryFilePath = path.join(project.path, project.entryFile);
    try {
        // Check if file exists first (optional, readFile will throw anyway)
        await fsPromises.stat(entryFilePath); 
        const buffer = await fsPromises.readFile(entryFilePath); // Use fsPromises
        const strategyCode = Buffer.from(buffer).toString('utf8');
        const backtraderStrategyClassPattern = /class\s+(\w+)\s*\((?:bt\.|backtrader\.)?Strategy\):/gm; 
        
        let match;
        let lastMatch: string | undefined;
        while ((match = backtraderStrategyClassPattern.exec(strategyCode)) !== null) {
            lastMatch = match[1];
        }
        
        if (lastMatch) {
            console.log(`Strategy class found: ${lastMatch} in ${entryFilePath}`);
            return lastMatch;
        } else {
            console.log(`No Backtrader strategy class found in ${entryFilePath} with pattern ${backtraderStrategyClassPattern}`);
            return undefined;
        }
    } catch (error) {
        console.error(`Error reading strategy file or finding class: ${entryFilePath}`, error);
        return undefined; 
    }
  }
}
