import * as path from 'path';
import * as zlib from 'zlib';
import { promisify } from 'util';
import { Backtest } from './types';
import { ProjectInfo } from './types';

export class Database {
  private static instance: Database;
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  private Datastore = require('@seald-io/nedb');
  private readonly CONFIG_FILE_NAME: string = '.backtest-man';
  private db: any;
  private initialized = false;
  private dbPath = '';
  private readonly gzip = promisify(zlib.gzip);
  private readonly gunzip = promisify(zlib.gunzip);

  private constructor() {}

  public static getInstance(workspacePath: string): Database {
    if (!Database.instance) {
      Database.instance = new Database();
      // Initialize is called, and it can throw, so getInstance can throw.
      Database.instance.initialize(workspacePath);
    } else if (!Database.instance.initialized) {
      // If instance exists but is not initialized (e.g. due to error in previous attempt)
      // and we are trying to get it again with a path.
      // This also handles the case where the first attempt to initialize failed.
      Database.instance.initialize(workspacePath);
    }
    
    // After attempting initialization (either for a new instance or an existing uninitialized one),
    // check if it's truly initialized. If not, something went wrong.
    if (!Database.instance.initialized) {
      // This line is crucial. If initialize failed, instance.initialized would be false.
      // We should throw an error here to indicate that getInstance couldn't provide an initialized Database.
      // The error thrown by initialize would typically be more specific.
      // This serves as a fallback or a clear indicator from getInstance's perspective.
      throw new Error('Database could not be initialized.');
    }

    return Database.instance;
  }

  private async unzipIfNeeded(line: string): Promise<string> {
    try {
      const buffer = Buffer.from(line, 'base64');
      if (buffer[0] === 0x1f && buffer[1] === 0x8b) {
        const decompressed = await this.gunzip(buffer);
        return decompressed.toString('utf-8');
      }
      return line;
    } catch (error) {
      throw new Error(`Error unzipping file: ${error}`);
    }
  }

  private async zip(line: string): Promise<string> {
    try {
      const compressed = await this.gzip(Buffer.from(line, 'utf-8'));
      return compressed.toString('base64');
    } catch (error) {
      throw new Error(`Error zipping file: ${error}`);
    }
  }

  private async initialize(workspacePath: string): Promise<void> {
    if (this.initialized) {
      return;
    }

    if (!workspacePath) {
        this.initialized = false; // Explicitly set to false
        throw new Error('Workspace path is required to initialize the database.');
    }

    try {
      this.dbPath = path.join(workspacePath, this.CONFIG_FILE_NAME);
      
      this.db = new this.Datastore({ 
        filename: this.dbPath, 
        autoload: true,
        beforeDeserialization: async (line: string) => {
          return await this.unzipIfNeeded(line);
        },
        afterSerialization: async (line: string) => {
          return await this.zip(line);
        }
      });
      
      this.db.setAutocompactionInterval(1000 * 60 * 10);
      
      this.initialized = true;
    } catch (error) {
      this.initialized = false; // Ensure it's marked as not initialized on error
      // Wrapping the original error to provide more context might be useful
      throw new Error(`Error initializing database at ${this.dbPath}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  public async getProjects(): Promise<(ProjectInfo & { results: Backtest[] })[]> {
    return await this.db.findAsync({});
  }

  public async getProject(projectId: string): Promise<(ProjectInfo & { results: Backtest[] }) | undefined> {
    return await this.db.findOneAsync({ _id: projectId });
  }

  public async getProjectByName(projectName: string): Promise<(ProjectInfo & { results: Backtest[] }) | undefined> {
    return await this.db.findOneAsync({ name: projectName });
  }

  public async addProject(projectData: ProjectInfo): Promise<ProjectInfo> {
    const projectToInsert = {
      ...projectData, // User-provided data (name, path, entryFile, engine, etc.)
      results: projectData.results || [], // Initialize if not present
      lastConfig: projectData.lastConfig || {}, // Initialize if not present
      created: projectData.created || new Date(), // Set if not present
      updated: projectData.updated || new Date(), // Set if not present
      // _id is automatically generated by NeDB upon insertion
    };
    // NeDB's insertAsync returns the inserted document with its _id
    const insertedProject = await this.db.insertAsync(projectToInsert);
    return insertedProject as ProjectInfo; // Cast because NeDB types might be generic
  }

  public async updateProject(projectId: string, updates: Partial<ProjectInfo>): Promise<void> {
    await this.db.updateAsync({ _id: projectId }, { $set: updates }, {});
  }

  public async updateLastConfig(projectId: string, config: any): Promise<void> {
    await this.db.updateAsync({ _id: projectId }, { $set: { lastConfig: config } }, {});
  }

  public async deleteProject(projectId: string): Promise<void> {
    const numRemoved = await this.db.removeAsync({ _id: projectId }, {});
    if (numRemoved === 0) {
      throw new Error(`Project not found: ${projectId}`);
    }
  }

  public async getBacktestResults(projectId: string): Promise<Backtest[]> {
    const project = await this.getProject(projectId);
    return project?.results || [];
  }

  public async addBacktestResult(projectId: string, result: Backtest): Promise<void> {
    const numUpdated = await this.db.updateAsync(
      { _id: projectId },
      { $push: { results: result } },
      {}
    );
    if (numUpdated === 0) {
      throw new Error(`Project not found: ${projectId}`);
    }
  }

  public async deleteBacktestResult(projectId: string, resultId: string): Promise<void> {
    const numUpdated = await this.db.updateAsync(
      { _id: projectId },
      { $pull: { results: { id: resultId } } },
      {}
    );
    if (numUpdated === 0) {
      throw new Error(`Project not found or backtest result not found: ${projectId}, ${resultId}`);
    }
  }

  public async saveDatabase(): Promise<void> {
    await this.db.persistence.compactDatafileAsync();
  }
}
